<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.12/ace.js" type="text/javascript"
            charset="utf-8"></script>
    <title>Video Test & Interactive Whiteboard</title>
    <link rel="stylesheet" href="../static/videoChat.css"/>
</head>
<body>

<select id="languageSelector">
    <option value="python">Python</option>
    <option value="java">Java</option>

</select>
<select id="problemSelector"></select>
<div id="problemDescription"></div>

<body style="display: flex; justify-content: center; align-items: center; margin: 0;">
<div id="editor" style="height: 500px; width: 700px;">print("Welcome to the expanded view!")</div>
</body>

<button id="runCode">Run Code</button>

<div id="output"></div>

<div id="container">
    <video id="video" width="480" height="360" autoplay></video>
    <div id="whiteboard-container">
        <canvas id="whiteboard" width="480" height="360"></canvas>

        <div class="tools">
            <div>
                <label for="colorPicker">选择颜色：</label>
                <input type="color" id="colorPicker" value="#000000">
            </div>

            <div>
                <label for="brushSize">画笔粗细：</label>
                <input type="range" id="brushSize" min="1" max="50" value="5">
                <span id="brushSizeDisplay">5</span>px
            </div>

            <button id="eraser">清除画布</button>
        </div>
    </div>
</div>


<script>

    function updateEditorContent() {
        const selectedLanguage = document.getElementById('languageSelector').value;
        const selectedProblemId = document.getElementById('problemSelector').value;

        fetch('/vac/get_problem_title', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({language: selectedLanguage, proID: selectedProblemId}),
        }).then(response => response.json())
            .then(data => {
                editor.setValue(data.title || '没有找到题目标题');
            })
            .catch(error => {
                console.error('Error:', error);
                editor.setValue('发生错误，无法加载题目标题');
            });

        fetch('/vac/get_problem_description', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({language: selectedLanguage, proID: selectedProblemId}),
        })

            .then(response => response.json())
            .then(data => {
                document.getElementById('problemDescription').textContent = data.description || '没有找到题目描述';
            })
            .catch(error => {
                console.error('Error:', error);
                document.getElementById('problemDescription').textContent = '发生错误，无法加载题目描述';
            });


    }

    // 监听语言和题目选择器的变化
    document.getElementById('languageSelector').addEventListener('change', updateEditorContent);
    document.getElementById('problemSelector').addEventListener('change', updateEditorContent);


    document.addEventListener('DOMContentLoaded', async () => {
        await getMedia();
        const constraints = {video: true, audio: true};
        const video = document.getElementById('video');
        let audioContext, analyser, dataArray;


        let optionValue = 1;//选择的题号

        fetch('/vac/get_problems')
            .then(response => response.json())
            .then(data => {
                const selectElement = document.getElementById('problemSelector');
                data.forEach(problem => {
                    const option = document.createElement('option');
                    optionValue = problem.ProID;
                    option.textContent = problem.ProID + ": " + problem.Description; // 或者使用 problem.javaTitle
                    selectElement.appendChild(option);
                });
            })
            .catch(error => console.error('Error:', error));

        let selectedProblemId;
        document.getElementById('problemSelector').addEventListener('change', function () {
            selectedProblemId = this.value;
            console.log("Selected Problem ID: ", selectedProblemId); // 用于调试
        });


        function handleSuccess(stream) {
            video.srcObject = stream;

            audioContext = new AudioContext();
            const audioSource = audioContext.createMediaStreamSource(stream);
            analyser = audioContext.createAnalyser();
            audioSource.connect(analyser);
            dataArray = new Uint8Array(analyser.frequencyBinCount);

            updateVolume();
        }

        function handleError(error) {
            console.error('getUserMedia error: ', error);
        }

        navigator.mediaDevices.getUserMedia(constraints).then(handleSuccess).catch(handleError);

        function updateVolume() {
            analyser.getByteFrequencyData(dataArray);
            let sum = dataArray.reduce((a, b) => a + b, 0);
            let volume = sum / dataArray.length;
            document.getElementById('volumeDisplay').textContent = 'Volume: ' + volume.toFixed(2);
            requestAnimationFrame(updateVolume);
        }

        const canvas = document.getElementById('whiteboard');
        const ctx = canvas.getContext('2d');
        let drawing = false;

        canvas.addEventListener('mousedown', () => {
            drawing = true;
        });

        canvas.addEventListener('mouseup', () => {
            drawing = false;
            ctx.beginPath();
        });

        canvas.addEventListener('mousemove', draw);

        function draw(event) {
            if (!drawing) return;
            ctx.lineWidth = document.getElementById('brushSize').value;
            ctx.lineCap = 'round';
            let rect = canvas.getBoundingClientRect();
            ctx.lineTo(event.clientX - rect.left, event.clientY - rect.top);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(event.clientX - rect.left, event.clientY - rect.top);
        }

        document.getElementById('colorPicker').addEventListener('change', (event) => {
            ctx.strokeStyle = event.target.value;
        });

        document.getElementById('brushSize').addEventListener('input', (event) => {
            document.getElementById('brushSizeDisplay').textContent = event.target.value;
        });

        document.getElementById('eraser').addEventListener('click', clearCanvas);

        function clearCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }
    });


    var editor = ace.edit("editor");
    editor.setTheme("ace/theme/monokai");
    editor.session.setMode("ace/mode/python");

    document.getElementById('languageSelector').addEventListener('change', function () {
        var language = this.value;
        editor.session.setMode("ace/mode/" + language);
    });

    document.getElementById('runCode').addEventListener('click', function () {
        var userCode = editor.getValue();
        var selectedLanguage = document.getElementById('languageSelector').value;
        var selectedProblemId = document.getElementById('problemSelector').value; // 获取当前选中的题目编号

        fetch('/vac/execute_code', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                code: userCode,
                language: selectedLanguage,
                proID: selectedProblemId // 将题目编号包含在请求体中
            }),
        })
            .then(response => response.json())
            .then(data => {
                if (data.output) {
                    document.getElementById('output').textContent = '输出: ' + data.output;
                } else if (data.error) {
                    document.getElementById('output').textContent = '错误: ' + data.error;
                }
            })
            .catch((error) => {
                console.error('Error:', error);
                document.getElementById('output').textContent = '发生错误：' + error;
            });
    });


    // WebRTC 相关代码
    const peerConnections = {}; // 用于存储所有的Peer连接
    const config = {'iceServers': [{'urls': 'stun:stun.l.google.com:19302'}]};

    // 创建 WebSocket 连接
    const signaling = new WebSocket('ws://localhost:8080');

    // 当 WebSocket 连接打开时
    signaling.onopen = () => console.log('Connected to signaling server');

    // 处理来自信令服务器的消息
    signaling.onmessage = async message => {
        const data = JSON.parse(message.data);
        const peerConnection = peerConnections[data.sender] || createPeerConnection(data.sender);

        if (data.offer) {
            await peerConnection.setRemoteDescription(new RTCSessionDescription(data.offer));
            const answer = await peerConnection.createAnswer();
            await peerConnection.setLocalDescription(answer);
            signaling.send(JSON.stringify({'answer': answer, 'receiver': data.sender}));
        } else if (data.answer) {
            await peerConnection.setRemoteDescription(new RTCSessionDescription(data.answer));
        } else if (data.ice) {
            await peerConnection.addIceCandidate(new RTCIceCandidate(data.ice));
        }
    };

    // 创建 WebRTC 连接
    function createPeerConnection(sender) {
        const peerConnection = new RTCPeerConnection(config);

        // 添加本地流到连接
        const stream = document.getElementById('video').srcObject;
        stream.getTracks().forEach(track => peerConnection.addTrack(track, stream));

        // 处理远程流
        peerConnection.ontrack = event => {
            const remoteVideo = document.createElement('video');
            remoteVideo.srcObject = event.streams[0];
            remoteVideo.autoplay = true;
            remoteVideo.muted = true;
            document.body.appendChild(remoteVideo); // 或添加到特定元素
        };

        // 处理 ICE 候选
        peerConnection.onicecandidate = event => {
            if (event.candidate) {
                signaling.send(JSON.stringify({'ice': event.candidate, 'receiver': sender}));
            }
        };

        peerConnections[sender] = peerConnection;
        return peerConnection;
    }

    // 获取本地媒体流
    async function getMedia() {
        const constraints = {video: true, audio: true};
        const stream = await navigator.mediaDevices.getUserMedia(constraints);
        document.getElementById('video').srcObject = stream;
    }


</script>


</body>
</html>